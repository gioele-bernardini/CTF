#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Maximum pattern length
#define MAX_PATTERN_LENGTH 10000

// Function to generate a unique pattern
char *generate_pattern(int length) {
  const char charset1[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const char charset2[] = "abcdefghijklmnopqrstuvwxyz";
  const char charset3[] = "0123456789";
  static char pattern[MAX_PATTERN_LENGTH];
  int i = 0;

  for (int a = 0; a < strlen(charset1) && i < length; a++) {
    for (int b = 0; b < strlen(charset2) && i < length; b++) {
      for (int c = 0; c < strlen(charset3) && i < length; c++) {
        pattern[i++] = charset1[a];
        if (i < length) pattern[i++] = charset2[b];
        if (i < length) pattern[i++] = charset3[c];
        if (i >= length) break;
      }
      if (i >= length) break;
    }
    if (i >= length) break;
  }
  pattern[i] = '\0'; // Null-terminate the string
  return pattern;
}

// Function to convert EIP from hexadecimal to ASCII string
void eip_to_string(unsigned int eip, char *eip_str) {
  eip_str[0] = (eip & 0xFF);
  eip_str[1] = ((eip >> 8) & 0xFF);
  eip_str[2] = ((eip >> 16) & 0xFF);
  eip_str[3] = ((eip >> 24) & 0xFF);
  eip_str[4] = '\0'; // Null-terminate the string
}

// Function to find the offset of the EIP string within the pattern
int find_offset(char *pattern, char *substring) {
  char *ptr = strstr(pattern, substring);
  if (ptr != NULL) {
    return ptr - pattern;
  } else {
    return -1; // Not found
  }
}

// Function to display the menu
void display_menu() {
  printf("=== Buffer Overflow Helper ===\n");
  printf("1) Generate Pattern\n");
  printf("2) Calculate Offset\n");
  printf("3) Exit\n");
  printf("Select an option: ");
}

int main() {
  int choice;
  while (1) {
    display_menu();
    if (scanf("%d", &choice) != 1) {
      printf("Invalid input. Please enter a number.\n");
      // Clear the input buffer
      while (getchar() != '\n');
      continue;
    }

    if (choice == 1) {
      // Option 1: Generate Pattern
      int pattern_length;
      printf("Enter the desired pattern length (1 - %d): ", MAX_PATTERN_LENGTH - 1);
      if (scanf("%d", &pattern_length) != 1) {
        printf("Invalid input. Please enter a numeric value.\n");
        // Clear the input buffer
        while (getchar() != '\n');
        continue;
      }

      if (pattern_length <= 0 || pattern_length >= MAX_PATTERN_LENGTH) {
        printf("Please enter a valid length between 1 and %d.\n", MAX_PATTERN_LENGTH - 1);
        continue;
      }

      char *pattern = generate_pattern(pattern_length);
      printf("\nGenerated Pattern (%d bytes):\n%s\n\n", pattern_length, pattern);

    } else if (choice == 2) {
      // Option 2: Calculate Offset
      unsigned int eip;
      char eip_input[9];
      char eip_str[5];
      int offset;
      char *pattern;

      printf("Enter the overwritten EIP value (in hexadecimal, e.g., 41306141 for 'Aa0A'):\n");
      scanf("%8s", eip_input);

      // Convert the input string to an unsigned integer
      if (sscanf(eip_input, "%x", &eip) != 1) {
        printf("Invalid EIP format. Please enter a valid hexadecimal value.\n\n");
        continue;
      }

      // Convert EIP to ASCII string
      eip_to_string(eip, eip_str);
      printf("EIP converted to ASCII: %.4s\n", eip_str);

      // Generate a large pattern to search within
      // Assuming the pattern used was sufficiently long
      pattern = generate_pattern(MAX_PATTERN_LENGTH - 1);

      // Find the offset
      offset = find_offset(pattern, eip_str);
      if (offset != -1) {
        printf("The EIP offset in the pattern is: %d bytes\n\n", offset);
      } else {
        printf("The EIP value was not found in the generated pattern.\n\n");
      }

    } else if (choice == 3) {
      // Option 3: Exit
      printf("Exiting the program.\n");
      break;
    } else {
      printf("Invalid choice. Please select a valid option.\n\n");
    }
  }

  return 0;
}

