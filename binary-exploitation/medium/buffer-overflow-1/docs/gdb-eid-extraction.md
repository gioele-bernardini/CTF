### Mini Report: Using GDB to Determine EIP Offset in Buffer Overflow

#### **Objective**
To utilize GDB (GNU Debugger) to identify the value of the Extended Instruction Pointer (EIP) after a buffer overflow crash, enabling the calculation of the offset required for crafting an exploit.

#### **Prerequisites**
- **GDB Installed**: Ensure GDB is installed on your system.
- **Vulnerable Program**: A compiled executable with a buffer overflow vulnerability.
- **Pattern Generator**: A tool or script to create a unique input pattern (as demonstrated in the previous C program).

#### **Steps to Determine the EIP Offset Using GDB**

1. **Launch GDB with the Vulnerable Program**

   Open your terminal and start GDB with the target executable:

   ```bash
   gdb ./vulnerable_program
   ```

2. **Run the Program with the Generated Pattern**

   Within the GDB prompt, execute the program by providing the unique pattern as input. Assuming you've generated a pattern of 200 bytes using your `pattern_offset` program:

   ```gdb
   (gdb) run $(./pattern_offset 200)
   ```

   *Alternatively*, you can manually input the pattern or redirect it from a file:

   ```gdb
   (gdb) run < input_pattern.txt
   ```

3. **Trigger the Buffer Overflow and Observe the Crash**

   The program should crash due to the buffer overflow. GDB will intercept the crash and provide relevant information, including the corrupted EIP.

   **Example Output:**

   ```
   Program received signal SIGSEGV, Segmentation fault.
   0x41306141 in ?? ()
   ```

   - **Signal Received**: `SIGSEGV` indicates a segmentation fault, typical of buffer overflows.
   - **Corrupted EIP**: `0x41306141` is the hexadecimal value that overwrote the EIP.

4. **Interpret the EIP Value**

   - **Hex to ASCII Conversion**: Convert the EIP value to its ASCII representation to match it against the generated pattern.
     
     Example:
     - `0x41` → `A`
     - `0x30` → `0`
     - `0x61` → `a`
     - `0x41` → `A`

     Thus, `0x41306141` translates to `"Aa0A"`.

5. **Calculate the Offset Using Your Pattern Offset Tool**

   Exit GDB and run your `pattern_offset` program, inputting the corrupted EIP value to find the exact offset.

   ```bash
   ./pattern_offset
   ```

   **Input Prompt:**
   ```
   Inserisci il valore EIP sovrascritto (es. 41414141 per 'AAAA'):
   41306141
   ```

   **Output:**
   ```
   EIP convertito in ASCII: Aa0A
   L'offset dell'EIP nel pattern è: 24 byte
   ```

   This indicates that the EIP was overwritten after **24 bytes** from the start of the buffer.

#### **Summary**

By following these steps, you can accurately determine the offset at which the EIP is overwritten in a buffer overflow scenario. This information is crucial for crafting effective exploits, as it allows you to control the flow of execution by injecting malicious payloads at the correct memory location.

#### **Example Workflow Recap**

1. **Start GDB:**
   ```bash
   gdb ./vulnerable_program
   ```

2. **Run with Pattern:**
   ```gdb
   (gdb) run $(./pattern_offset 200)
   ```

3. **Observe Crash:**
   ```
   Program received signal SIGSEGV, Segmentation fault.
   0x41306141 in ?? ()
   ```

4. **Calculate Offset:**
   ```bash
   ./pattern_offset
   ```
   *Input:* `41306141`  
   *Output:* `Offset = 24 bytes`

#### **Final Notes**
- **Safety First**: Always perform buffer overflow testing in a controlled and legal environment to avoid unintended consequences.
- **Further Steps**: Once the offset is known, proceed to inject payloads (e.g., shellcode) at the determined location to achieve desired exploit outcomes.

