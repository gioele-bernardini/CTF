### November 19, 2024

# Stonks

## Solution

The challenge requires some understanding of **C**. First off, after taking a look at the *source code*, a function catches my interest:

```C
int buy_stonks(Portfolio *p) {
  if (!p) {
    return 1;
  }
  char api_buf[FLAG_BUFFER];
  FILE *f = fopen("api", "r");
  if (!f) {
    printf("Flag file not found. Contact an admin.\n");
    exit(1);
  }
  fgets(api_buf, FLAG_BUFFER, f);

  // Rest of the code

  char *user_buf = malloc(300 + 1);
  printf("What is your API token?\n");
  scanf("%300s", user_buf);
  printf("Buying stonks with token:\n");
  printf(user_buf);

  // TODO: Actually use key to interact with API

  view_portfolio(p);

  return 0;
}
```

Hey, we may take advantage of a **format string vulnerability**!

Indeed, the function stores the contents of the `api` file right into its **stack frame**, and this allows us, by executing a **stack dump**, to retrieve the values without having to jump from one frame to another with all the problems that arise from having to preserve the **EIP** and **EBP** in turn.

**Great**, how do we proceed?

Let's remember that the dump will **climb the stack**.

Below (lower addresses, I'm imagining the stack growing downwards) the frame of `buy_stonks` will be generated by the stack of `printf`. This will take the `format` argument.

Below that will then be allocated the **return address**, managed by the **EIP**, and then the function itself the **EBP**.

However, `printf` is **variadic** and does not control beforehand that the placeholders match the number of arguments passed, as it could, after all, accept *virtually* an infinite number.

So, if we **don't specify the format**, the format will be our input string, and if there are more placeholders than arguments, `printf` will climb the stack to print them, believing that memory is allocated and everything goes as planned.

Once it climbs its frame, it will climb to the frame of the previously running function (which passed it the program's control flow).

Let's remember that, in a **buffer**—in our case where the content of `api` is stored—data is also stored from lower to higher addresses (higher addresses) on the stack. Space is allocated starting from the current **EBP** and then filled.

Consequently, the characters printed by climbing the stack are in order... or maybe not?

Indeed, the content is stored from lower to higher addresses, and this aligns with our climbing the stack. But it's stored in **little endian**, and consequently, we need to order the bytes within the **DWORDs** (the stack is segmented by DWORD).

Taking an example:

Suppose the flag is `picoCTF{abcd1234}`.

**Storage in Hex (without the braces)**:
```
70 69 63 6F 43 54 46 7B 61 62 63 64 31 32 33 34 7D
```

**Division into DWORDs**:
| DWORD | Hex          | ASCII   |
|-------|--------------|---------|
| 1     | 70 69 63 6F  | p i c o |
| 2     | 43 54 46 7B  | C T F { |
| 3     | 61 62 63 64  | a b c d |
| 4     | 31 32 33 34  | 1 2 3 4 |
| 5     | 7D           | }       |

**Byte Reversal (Little Endian)**:
| DWORD | Reversed Hex | ASCII   |
|-------|--------------|---------|
| 1     | 6F 63 69 70  | o c i p |
| 2     | 7B 46 54 43  | { F T C |
| 3     | 64 63 62 61  | d c b a |
| 4     | 34 33 32 31  | 4 3 2 1 |
| 5     | 7D           | }       |

**Reconstructed String**:
```
ocip{FTCdcbA4321}
```

**That's all!**

The exploit **follows step by step** the reasoning I've done so far :)

Moreover, in the last `if` statement, it **skips the check** for values that are not 8 characters long. This is because the string is stored sequentially, one after another, and given **little endian** byte ordering, even the boundaries of the `api` content must form complete **DWORDs** without being truncated. As a result, it **bypasses** dumped values such as padding or other variables within the stack.

