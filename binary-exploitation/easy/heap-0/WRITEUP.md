# Writeup

## Explanation

The challenge is relatively straightforward once you understand how the heap operates. Let's recap the stack and heap layout:

The heap grows towards **higher** memory addresses, which is why the second variable is placed at a higher address. Keeping the hexadecimal system in mind, we can easily calculate the distance—in terms of **bytes** (since our addressing is byte-based)—between the two variables:

```
0x5f202a4696b0 - 0x5f202a4696d0 = 16 bytes
```

Since we know that a Unicode character is exactly **1 byte** long, we can determine that to overwrite the content of the second variable, we need to write **16 + 1** characters. The additional character accounts for an **off-by-one error**:

```python
print('x' * 32 + 'pwned')
```

By selecting the mode for printing the stack, we can correctly visualize that the `pico` variable has been replaced with the string `pwned`:

```
Heap State:
+------------------+----------------+
| Address          | Heap Data      |
+------------------+----------------+
| 0x5f202a4696b0   | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx |
+------------------+----------------+
| 0x5f202a4696d0   | pwned          |
+------------------+----------------+
```

By selecting option **4** to check the win condition, we will ultimately obtain the flag.

### Off-by-One Error Explained

An **off-by-one error** occurs when a program writes data one position too far, either before the start or beyond the end of a buffer. In this challenge, writing `16 + 1` characters ensures that we overwrite the second variable without causing unintended behavior or crashing the program. Being precise with buffer sizes is crucial to prevent such vulnerabilities.