## Explanation

The challenge becomes relatively straightforward once you understand how the heap operates. Let’s recap the stack and heap layout:

The heap grows towards **higher** memory addresses, which is why the second variable is placed at a higher address. Keeping the hexadecimal system in mind, we can easily calculate the distance—in terms of **bytes** (since our addressing is byte-based)—between the two variables:

```
0x5f202a4696b0 - 0x5f202a4696d0 = 0x20 [bytes]
```

This distance is exactly 32 in the decimal system. Since we know that a Unicode character occupies exactly **1 byte**, we can determine that to overwrite the content of the second variable, we need to write at least **32 + 1** characters to overwrite the initial part of `safe_var`.

```python
print('x' * 32 + 'test')
```

By selecting the mode for printing the stack, we can correctly visualize that the `pico` variable has been replaced with the string `test`:

```
Heap State:
+------------------+--------------------------------------+
| Address          | Heap Data                            |
+------------------+--------------------------------------+
| 0x5f202a4696b0   | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxtest |
+------------------+--------------------------------------+
| 0x5f202a4696d0   | test                                 |
+------------------+--------------------------------------+
```

Note that the first variable, when printed, will include `test` within itself, as `printf` will print out until the first null character is encountered!

By selecting option **4** to check the win condition, we will ultimately obtain the flag.

