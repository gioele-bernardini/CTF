# Solution

## Explanation

The challenge requires an understanding of format string vulnerabilities. In C, a **format string vulnerability** occurs when `printf` (or similar functions) are called without properly passing formatting parameters, thereby allowing unexpected and potentially dangerous behaviors.

```C
#include <stdio.h>

int main() {
  int out = 10;
  printf(out); // Format string vulnerability
  return 0;
}
```

In this example, `printf` should receive a format string, such as `"%d"`, to indicate that we want to print an integer. However, without the `%d` placeholder, `printf` attempts to interpret the integer `out` as a format string, causing undefined behavior and opening the door to potential exploits.

### Example 1: Unintentional Printing

A simple example that demonstrates the danger of a format string vulnerability is as follows:

```C
#include <stdio.h>

int main() {
  char str[100];
  scanf("%s", str);       // Suppose the user inputs "%x %x %x %x"
  printf(str);            // Will print arbitrary contents from memory
  return 0;
}
```

If the user inputs something like `"%x %x %x %x"`, `printf` will print values from memory, displaying data from various addresses. This vulnerability is particularly dangerous in security-sensitive contexts.

### Example 2: Memory Manipulation

In more advanced scenarios, this vulnerability can be used to overwrite values in memory. By using the `%n` format specifier, we can modify the content of specific addresses:

```C
#include <stdio.h>

int main() {
  int target = 0;
  printf("I want to write here %x%n", 0, &target);
  printf("target = %d\n", target);  // Now target is modified
  return 0;
}
```

With `%n`, `printf` writes the number of characters printed so far to the provided address, allowing manipulation of crucial variables.

---

Now that we have an idea of how the vulnerability works, let's move on to the challenge. Here, the "**value** of the burger" is based on the return value of `printf`, which returns the number of characters successfully printed.

None of the burgers have a value exceeding 64, as highlighted in the code. However, by exploiting this vulnerability, we can create a burger name that contains a `%`, which will cause unintended behavior, such as a **stack dump** revealing values in memory. Thus, the number of characters printed will be significantly different.

Finally, the same principle is applied in the last round.

---

## Technical Walkthrough of the Code

### Functions of Interest

1. `sigsegv_handler(int sig)`: This function is the handler for the `SIGSEGV` signal. In case of a segmentation fault, it prints the contents of the `flag` variable, which contains the hidden flag for the challenge.

2. `on_menu(char *burger, char *menu[], int count)`: This function checks if a specified burger is present in the menu, returning 1 if present and 0 if absent.

3. `serve_patrick` and `serve_bob`: These two functions handle the logic for serving the two customers. In `serve_patrick`, if the return value of `printf` is greater than `2 * BUFSIZE`, it proceeds to the `serve_bob` function.

### Explanation of the Exploit Logic

In the `serve_patrick` function, the user's input is printed with `printf(choice1)`, which introduces the format string vulnerability. By manipulating the input, we can print values from the stack and cause unexpected behaviors. To progress in the challenge, we need to create an input that, once passed to `printf`, prints a sufficient number of characters to satisfy the condition `count > 2 * BUFSIZE`.

### Final Exploit

We repeat the process in the `serve_bob` function, which requests new input for the second customer. Here too, we can insert format string characters to achieve similar behavior, ultimately triggering a segmentation fault. This activates the `sigsegv_handler`, which prints the flag.

